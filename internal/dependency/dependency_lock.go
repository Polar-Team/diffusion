package dependency

import (
	"fmt"
	"log"
	"os"
	"strings"
	"time"

	"diffusion/internal/config"
	"diffusion/internal/galaxy"
	"diffusion/internal/role"

	"gopkg.in/yaml.v3"
)

// LockFileEntry represents a single dependency entry in the lock file
type LockFileEntry struct {
	Name            string            `yaml:"name"`
	Version         string            `yaml:"version"`
	ResolvedVersion string            `yaml:"resolved_version,omitempty"` // Actual version (e.g., "7.5.0" for ">=7.4.0")
	Type            string            `yaml:"type"`                       // "collection", "role", "tool"
	Hash            string            `yaml:"hash,omitempty"`
	PythonDeps      map[string]string `yaml:"python_deps,omitempty"` // Python dependencies with versions
	Src             string            `yaml:"src,omitempty"`         // Source URL for roles (git repo)
	Source          string            `yaml:"scm,omitempty"`         // SCM type for roles (git, hg, etc.)
}

// LockFile represents the diffusion.lock file structure
type LockFile struct {
	Version     string                `yaml:"version"`     // Lock file format version
	Generated   string                `yaml:"generated"`   // Timestamp
	Hash        string                `yaml:"hash"`        // Overall dependency hash
	Python      *config.PythonVersion `yaml:"python"`      // Python version info
	Collections []LockFileEntry       `yaml:"collections"` // Locked collections
	Roles       []LockFileEntry       `yaml:"roles"`       // Locked roles
	Tools       []LockFileEntry       `yaml:"tools"`       // Locked tools (ansible, molecule, etc.)
}

const (
	LockFileVersion = "1.0"
)

// LoadLockFile loads the diffusion.lock file
func LoadLockFile() (*LockFile, error) {
	data, err := os.ReadFile(config.LockFileName)
	if err != nil {
		if os.IsNotExist(err) {
			return nil, nil // Lock file doesn't exist yet
		}
		return nil, fmt.Errorf("failed to read lock file: %w", err)
	}

	var lockFile LockFile
	if err := yaml.Unmarshal(data, &lockFile); err != nil {
		return nil, fmt.Errorf("failed to parse lock file: %w", err)
	}

	return &lockFile, nil
}

// SaveLockFile saves the lock file
func SaveLockFile(lockFile *LockFile) error {
	lockFile.Version = LockFileVersion
	lockFile.Generated = time.Now().UTC().Format(time.RFC3339)

	data, err := yaml.Marshal(lockFile)
	if err != nil {
		return fmt.Errorf("failed to marshal lock file: %w", err)
	}

	// Add header comment
	header := fmt.Sprintf("# This file is automatically generated by diffusion.\n# Do not edit this file manually.\n# Generated: %s\n\n", lockFile.Generated)
	data = append([]byte(header), data...)

	if err := os.WriteFile(config.LockFileName, data, 0644); err != nil {
		return fmt.Errorf("failed to write lock file: %w", err)
	}

	return nil
}

// GenerateLockFile generates a new lock file from current dependencies with resolved versions
func GenerateLockFile(collections []config.CollectionRequirement, roles []config.RoleRequirement, toolVersions map[string]string, pythonVersion *config.PythonVersion) (*LockFile, error) {
	lockFile := &LockFile{
		Version:     LockFileVersion,
		Python:      pythonVersion,
		Collections: make([]LockFileEntry, 0),
		Roles:       make([]LockFileEntry, 0),
		Tools:       make([]LockFileEntry, 0),
	}

	galaxyAPI := galaxy.NewGalaxyAPI()

	// Add collections with resolved versions
	for _, col := range collections {
		if col.Source == "" {
			col.Source = "galaxy"
		}
		entry := LockFileEntry{
			Name:    col.Name,
			Version: col.Version,
			Type:    "collection",
			Source:  col.Source,
			Src:     col.SourceURL,
		}

		if col.Source != "galaxy" {
			// For non-Galaxy sources we are trying to resolve from git
			if col.SourceURL == "" {
				log.Printf("Skipping collection %s: missing source URL for non-Galaxy source %s", col.Name, col.Source)
				continue
			}

			resolvedVersion, err := galaxy.ResolveVersionFromGit(col.SourceURL, col.Version)
			if err != nil {
				log.Printf("Failed to resolve version for collection %s from git: %v", col.Name, err)
				// Use the version constraint if resolution fails
				if col.Version != "" && col.Version != "latest" {
					entry.ResolvedVersion = col.Version
				} else {
					entry.ResolvedVersion = "main"
				}
			} else {
				entry.ResolvedVersion = resolvedVersion
			}
		} else {
			// Resolve version from Galaxy
			resolvedVersion, err := galaxyAPI.ResolveVersion(col.Name, "collection", col.Version)
			if err != nil {
				fmt.Printf("Warning: Failed to resolve version for %s: %v\n", col.Name, err)
				// Use the version constraint if resolution fails
				if col.Version != "" && col.Version != "latest" {
					entry.ResolvedVersion = col.Version
				} else {
					entry.ResolvedVersion = "latest"
				}
			} else {
				entry.ResolvedVersion = resolvedVersion
			}
		}

		// Get Python dependencies for this collection
		pythonDeps := getCollectionPythonDependencies(col.Name)
		if len(pythonDeps) > 0 {
			// Resolve Python package versions
			resolved, err := galaxy.ResolvePythonDependencies(pythonDeps)
			if err != nil {
				fmt.Printf("Warning: Failed to resolve Python deps for %s: %v\n", col.Name, err)
			} else {
				entry.PythonDeps = resolved
			}
		}

		lockFile.Collections = append(lockFile.Collections, entry)
	}

	// Add roles with resolved versions
	for _, role := range roles {
		if role.Scm == "" {
			role.Scm = "git"
		}

		entry := LockFileEntry{
			Name:    role.Name,
			Version: role.Version, // This is the constraint from diffusion.toml
			Type:    "role",
			Src:     role.Src, // Store git URL
			Source:  role.Scm, // Store SCM type (git, hg, etc.) - yaml tag is "scm"
		}

		// Determine resolution strategy based on source
		resolved := false

		// Priority 1: If git URL is provided, resolve from git
		if role.Src != "" && (strings.Contains(role.Src, "github.com") || strings.Contains(role.Src, "gitlab.com") || strings.HasSuffix(role.Src, ".git")) {
			resolvedVersion, err := galaxy.ResolveVersionFromGit(role.Src, role.Version)
			if err != nil {
				fmt.Printf("Warning: Failed to resolve version for role %s from git: %v\n", role.Name, err)
				// If resolution fails but we have a version constraint, use it
				if role.Version != "" && role.Version != "latest" {
					entry.ResolvedVersion = role.Version
					resolved = true
				}
			} else {
				entry.ResolvedVersion = resolvedVersion
				resolved = true
			}
		}

		// Priority 2: If not resolved and has namespace, try Galaxy API
		if !resolved {
			parts := strings.Split(role.Name, ".")
			if len(parts) == 2 {
				resolvedVersion, err := galaxyAPI.ResolveRoleVersion(parts[0], parts[1], role.Version)
				if err != nil {
					fmt.Printf("Warning: Failed to resolve version for role %s from Galaxy: %v\n", role.Name, err)
				} else {
					entry.ResolvedVersion = resolvedVersion
					resolved = true
				}
			}
		}

		// Fallback: Use constraint or default to "main"
		if !resolved {
			if role.Version == "" || role.Version == "latest" || role.Version == "main" {
				entry.ResolvedVersion = "main"
			} else {
				// Use the version constraint as resolved version
				entry.ResolvedVersion = role.Version
			}
		}

		lockFile.Roles = append(lockFile.Roles, entry)
	}

	// Add tools with resolved Python package versions
	toolPackages := []string{}
	for tool, version := range toolVersions {
		entry := LockFileEntry{
			Name:    tool,
			Version: version,
			Type:    "tool",
			Source:  "pypi",
		}

		// Format as Python package
		pkgName := formatDependency(tool, version)
		toolPackages = append(toolPackages, pkgName)

		lockFile.Tools = append(lockFile.Tools, entry)
	}

	// Resolve all tool versions from PyPI
	if len(toolPackages) > 0 {
		resolved, err := galaxy.ResolvePythonDependencies(toolPackages)
		if err != nil {
			fmt.Printf("Warning: Failed to resolve tool versions: %v\n", err)
		} else {
			// Update tool entries with resolved versions
			for i := range lockFile.Tools {
				if resolvedVer, ok := resolved[lockFile.Tools[i].Name]; ok {
					lockFile.Tools[i].ResolvedVersion = resolvedVer
				}
			}
		}
	}

	// Compute overall hash
	lockFile.Hash = ComputeDependencyHash(collections, roles, toolVersions, pythonVersion)

	return lockFile, nil
}

// ValidateLockFile validates if the lock file is up-to-date
func ValidateLockFile(lockFile *LockFile, collections []config.CollectionRequirement, roles []config.RoleRequirement, toolVersions map[string]string, pythonVersion *config.PythonVersion) (bool, error) {
	if lockFile == nil {
		return false, nil
	}
	currentHash := ComputeDependencyHash(collections, roles, toolVersions, pythonVersion)
	return lockFile.Hash == currentHash, nil
}

// UpdateLockFile updates the lock file with current dependencies
func UpdateLockFile() error {
	// Load current configuration
	depConfig, err := LoadDependencyConfig()
	if err != nil {
		return fmt.Errorf("failed to load dependency config: %w", err)
	}

	// Convert depConfig to resolver format
	// Collections: use directly from depConfig
	collections := depConfig.Collections
	if collections == nil {
		collections = []config.CollectionRequirement{}
	}

	// Roles: use directly from depConfig (already normalized in LoadDependencyConfig)
	roles := depConfig.Roles
	if roles == nil {
		roles = []config.RoleRequirement{}
	}

	// Python version
	pythonVersion := depConfig.Python
	if pythonVersion == nil {
		pythonVersion = &config.PythonVersion{
			Min:    config.DefaultMinPythonVersion,
			Max:    config.DefaultMaxPythonVersion,
			Pinned: config.PinnedPythonVersion,
		}
	}

	// Tool versions
	toolVersions := map[string]string{
		"ansible":      depConfig.Ansible,
		"molecule":     depConfig.Molecule,
		"ansible-lint": depConfig.AnsibleLint,
		"yamllint":     depConfig.YamlLint,
	}

	// Set defaults for empty tool versions
	if toolVersions["ansible"] == "" {
		toolVersions["ansible"] = config.DefaultAnsibleVersion
	}
	if toolVersions["molecule"] == "" {
		toolVersions["molecule"] = config.DefaultMoleculeVersion
	}
	if toolVersions["ansible-lint"] == "" {
		toolVersions["ansible-lint"] = config.DefaultAnsibleLintVersion
	}
	if toolVersions["yamllint"] == "" {
		toolVersions["yamllint"] = config.DefaultYamlLintVersion
	}

	// Generate and save lock file
	lockFile, err := GenerateLockFile(collections, roles, toolVersions, pythonVersion)
	if err != nil {
		return fmt.Errorf("failed to generate lock file: %w", err)
	}

	if err := SaveLockFile(lockFile); err != nil {
		return fmt.Errorf("failed to save lock file: %w", err)
	}

	return nil
}

// CheckLockFileStatus checks if lock file is up-to-date
func CheckLockFileStatus() (bool, error) {
	lockFile, err := LoadLockFile()
	if err != nil {
		return false, err
	}

	if lockFile == nil {
		return false, nil // No lock file exists
	}

	depsConfig, err := LoadDependencyConfig()
	if err != nil {
		return false, fmt.Errorf("failed to load dependency config: %w", err)
	}

	scenarios := []string{}
	for _, role := range depsConfig.Roles {
		// Normalize role source if missing

		parts := strings.SplitN(role.Name, ".", 2)
		var scenarioName string
		if len(parts) == 2 {
			scenarioName = parts[0]
		} else if scenarioName == "default" || scenarioName == "" {
			scenarioName = "default"
		}
		scenarios = append(scenarios, scenarioName)
	}

	roles := []config.RoleRequirement{}
	// Load requirements for each scenario
	for _, scenario := range scenarios {
		meta, req, err := role.LoadRoleConfig(scenario)
		if err != nil {
			return false, fmt.Errorf("failed to load role config for scenario %s: %w", scenario, err)
		}

		for role := range req.Roles {
			roles = append(roles, config.RoleRequirement{
				Name:    fmt.Sprintf("%s.%s", scenario, req.Roles[role].Name),
				Src:     req.Roles[role].Src,
				Scm:     req.Roles[role].Scm,
				Version: req.Roles[role].Version,
			})
		}
		_ = meta // Currently not used
	}

	collections := []config.CollectionRequirement{}
	_, req, err := role.LoadRoleConfig("")
	if err != nil {
		return false, fmt.Errorf("failed to load default role config: %w", err)
	}
	for collection := range req.Collections {
		collections = append(collections, config.CollectionRequirement{
			Name:      req.Collections[collection].Name,
			Source:    req.Collections[collection].Source,
			SourceURL: req.Collections[collection].SourceURL,
			Version:   req.Collections[collection].Version,
		})
	}

	toolVersions := map[string]string{
		"ansible":      depsConfig.Ansible,
		"molecule":     depsConfig.Molecule,
		"ansible-lint": depsConfig.AnsibleLint,
		"yamllint":     depsConfig.YamlLint,
	}

	// Validate lock file
	return ValidateLockFile(lockFile, collections, roles, toolVersions, depsConfig.Python)
}
