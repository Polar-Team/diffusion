package main

import (
	"fmt"
	"log"
	"os"
	"strings"
	"time"

	"gopkg.in/yaml.v3"
)

// LockFileEntry represents a single dependency entry in the lock file
type LockFileEntry struct {
	Name            string            `yaml:"name"`
	Version         string            `yaml:"version"`
	ResolvedVersion string            `yaml:"resolved_version,omitempty"` // Actual version (e.g., "7.5.0" for ">=7.4.0")
	Type            string            `yaml:"type"`                       // "collection", "role", "tool"
	Hash            string            `yaml:"hash,omitempty"`
	PythonDeps      map[string]string `yaml:"python_deps,omitempty"` // Python dependencies with versions
	Src             string            `yaml:"src,omitempty"`         // Source URL for roles (git repo)
	Source          string            `yaml:"scm,omitempty"`         // SCM type for roles (git, hg, etc.)
}

// LockFile represents the diffusion.lock file structure
type LockFile struct {
	Version     string          `yaml:"version"`     // Lock file format version
	Generated   string          `yaml:"generated"`   // Timestamp
	Hash        string          `yaml:"hash"`        // Overall dependency hash
	Python      *PythonVersion  `yaml:"python"`      // Python version info
	Collections []LockFileEntry `yaml:"collections"` // Locked collections
	Roles       []LockFileEntry `yaml:"roles"`       // Locked roles
	Tools       []LockFileEntry `yaml:"tools"`       // Locked tools (ansible, molecule, etc.)
}

const (
	LockFileVersion = "1.0"
)

// LoadLockFile loads the diffusion.lock file
func LoadLockFile() (*LockFile, error) {
	data, err := os.ReadFile(LockFileName)
	if err != nil {
		if os.IsNotExist(err) {
			return nil, nil // Lock file doesn't exist yet
		}
		return nil, fmt.Errorf("failed to read lock file: %w", err)
	}

	var lockFile LockFile
	if err := yaml.Unmarshal(data, &lockFile); err != nil {
		return nil, fmt.Errorf("failed to parse lock file: %w", err)
	}

	return &lockFile, nil
}

// SaveLockFile saves the lock file
func SaveLockFile(lockFile *LockFile) error {
	lockFile.Version = LockFileVersion
	lockFile.Generated = time.Now().UTC().Format(time.RFC3339)

	data, err := yaml.Marshal(lockFile)
	if err != nil {
		return fmt.Errorf("failed to marshal lock file: %w", err)
	}

	// Add header comment
	header := fmt.Sprintf("# This file is automatically generated by diffusion.\n# Do not edit this file manually.\n# Generated: %s\n\n", lockFile.Generated)
	data = append([]byte(header), data...)

	if err := os.WriteFile(LockFileName, data, 0644); err != nil {
		return fmt.Errorf("failed to write lock file: %w", err)
	}

	return nil
}

// GenerateLockFile generates a new lock file from current dependencies with resolved versions
func GenerateLockFile(collections []CollectionRequirement, roles []RoleRequirement, toolVersions map[string]string, pythonVersion *PythonVersion) (*LockFile, error) {
	lockFile := &LockFile{
		Version:     LockFileVersion,
		Python:      pythonVersion,
		Collections: make([]LockFileEntry, 0),
		Roles:       make([]LockFileEntry, 0),
		Tools:       make([]LockFileEntry, 0),
	}

	galaxyAPI := NewGalaxyAPI()

	// Add collections with resolved versions
	for _, col := range collections {
		if col.Source == "" {
			col.Source = "galaxy"
		}
		entry := LockFileEntry{
			Name:    col.Name,
			Version: col.Version,
			Type:    "collection",
			Source:  col.Source,
			Src:     col.SourceURL,
		}

		if col.Source != "galaxy" {
			// For non-Galaxy sources we are trying to resolve from git

			if col.SourceURL == "" {
				log.Printf("Skipping collection %s: missing source URL for non-Galaxy source %s", col.Name, col.Source)
			}

			resolvedVersion, err := ResolveVersionFromGit(col.SourceURL, col.Version)
			if err != nil {
				log.Printf("Failed to resolve version for collection %s from git: %v", col.Name, err)
				entry.ResolvedVersion = col.Version
			} else {
				entry.ResolvedVersion = resolvedVersion
			}
		} else {
			// Resolve version from Galaxy
			resolvedVersion, err := galaxyAPI.ResolveVersion(col.Name, "collection", col.Version)
			if err != nil {
				fmt.Printf("Warning: Failed to resolve version for %s: %v\n", col.Name, err)
				entry.ResolvedVersion = col.Version
			} else {
				entry.ResolvedVersion = resolvedVersion
			}
		}

		// Get Python dependencies for this collection
		pythonDeps := getCollectionPythonDependencies(col.Name)
		if len(pythonDeps) > 0 {
			// Resolve Python package versions
			resolved, err := ResolvePythonDependencies(pythonDeps)
			if err != nil {
				fmt.Printf("Warning: Failed to resolve Python deps for %s: %v\n", col.Name, err)
			} else {
				entry.PythonDeps = resolved
			}
		}

		lockFile.Collections = append(lockFile.Collections, entry)
	}

	// Add roles with resolved versions
	for _, role := range roles {
		if role.Scm == "" {
			role.Scm = "git"
		}
		entry := LockFileEntry{
			Name:    role.Name,
			Version: role.Version, // This is the constraint from diffusion.toml
			Type:    "role",
			Src:     role.Src, // Store git URL
			Source:  role.Scm, // Store SCM type (git, hg, etc.) - yaml tag is "scm"
		}

		// Determine resolution strategy based on source
		resolved := false

		// Priority 1: If git URL is provided, resolve from git
		if role.Src != "" && (strings.Contains(role.Src, "github.com") || strings.Contains(role.Src, "gitlab.com") || strings.HasSuffix(role.Src, ".git")) {
			resolvedVersion, err := ResolveVersionFromGit(role.Src, role.Version)
			if err != nil {
				fmt.Printf("Warning: Failed to resolve version for role %s from git: %v\n", role.Name, err)
			} else {
				entry.ResolvedVersion = resolvedVersion
				resolved = true
			}
		}

		// Priority 2: If not resolved and has namespace, try Galaxy API
		if !resolved {
			parts := strings.Split(role.Name, ".")
			if len(parts) == 2 {
				resolvedVersion, err := galaxyAPI.ResolveRoleVersion(parts[0], parts[1], role.Version)
				if err != nil {
					fmt.Printf("Warning: Failed to resolve version for role %s from Galaxy: %v\n", role.Name, err)
				} else {
					entry.ResolvedVersion = resolvedVersion
					resolved = true
				}
			}
		}

		// Fallback: Use constraint or default
		if !resolved {
			if role.Version == "" || role.Version == "latest" {
				entry.ResolvedVersion = "main"
			} else {
				entry.ResolvedVersion = role.Version
			}
		}

		lockFile.Roles = append(lockFile.Roles, entry)
	}

	// Add tools with resolved Python package versions
	toolPackages := []string{}
	for tool, version := range toolVersions {
		entry := LockFileEntry{
			Name:    tool,
			Version: version,
			Type:    "tool",
			Source:  "pypi",
		}

		// Format as Python package
		pkgName := formatDependency(tool, version)
		toolPackages = append(toolPackages, pkgName)

		lockFile.Tools = append(lockFile.Tools, entry)
	}

	// Resolve all tool versions from PyPI
	if len(toolPackages) > 0 {
		resolved, err := ResolvePythonDependencies(toolPackages)
		if err != nil {
			fmt.Printf("Warning: Failed to resolve tool versions: %v\n", err)
		} else {
			// Update tool entries with resolved versions
			for i := range lockFile.Tools {
				if resolvedVer, ok := resolved[lockFile.Tools[i].Name]; ok {
					lockFile.Tools[i].ResolvedVersion = resolvedVer
				}
			}
		}
	}

	// Compute overall hash
	lockFile.Hash = ComputeDependencyHash(collections, roles, toolVersions, pythonVersion)

	return lockFile, nil
}

// ValidateLockFile validates if the lock file is up-to-date
func ValidateLockFile(lockFile *LockFile, collections []CollectionRequirement, roles []RoleRequirement, toolVersions map[string]string, pythonVersion *PythonVersion) (bool, error) {
	if lockFile == nil {
		return false, nil
	}

	currentHash := ComputeDependencyHash(collections, roles, toolVersions, pythonVersion)
	return lockFile.Hash == currentHash, nil
}

// UpdateLockFile updates the lock file with current dependencies
func UpdateLockFile() error {
	// Load current configuration
	depConfig, err := LoadDependencyConfig()
	if err != nil {
		return fmt.Errorf("failed to load dependency config: %w", err)
	}

	// Load meta and requirements
	meta, req, err := LoadRoleConfig("")
	if err != nil {
		return fmt.Errorf("failed to load role config: %w", err)
	}

	// Resolve dependencies
	resolver := NewDependencyResolver(meta, req, depConfig)
	collections, err := resolver.ResolveCollectionDependencies()
	if err != nil {
		return fmt.Errorf("failed to resolve collections: %w", err)
	}

	roles, err := resolver.ResolveRoleDependencies()
	if err != nil {
		return fmt.Errorf("failed to resolve roles: %w", err)
	}

	pythonVersion := resolver.ResolvePythonVersion()
	toolVersions := resolver.ResolveToolVersions()

	// Generate and save lock file
	lockFile, err := GenerateLockFile(collections, roles, toolVersions, pythonVersion)
	if err != nil {
		return fmt.Errorf("failed to generate lock file: %w", err)
	}

	if err := SaveLockFile(lockFile); err != nil {
		return fmt.Errorf("failed to save lock file: %w", err)
	}

	return nil
}

// CheckLockFileStatus checks if lock file is up-to-date
func CheckLockFileStatus() (bool, error) {
	lockFile, err := LoadLockFile()
	if err != nil {
		return false, err
	}

	if lockFile == nil {
		return false, nil // No lock file exists
	}

	// Load current configuration
	depConfig, err := LoadDependencyConfig()
	if err != nil {
		return false, fmt.Errorf("failed to load dependency config: %w", err)
	}

	// Load meta and requirements
	meta, req, err := LoadRoleConfig("")
	if err != nil {
		return false, fmt.Errorf("failed to load role config: %w", err)
	}

	// Resolve dependencies
	resolver := NewDependencyResolver(meta, req, depConfig)
	collections, err := resolver.ResolveCollectionDependencies()
	if err != nil {
		return false, fmt.Errorf("failed to resolve collections: %w", err)
	}

	roles, err := resolver.ResolveRoleDependencies()
	if err != nil {
		return false, fmt.Errorf("failed to resolve roles: %w", err)
	}

	pythonVersion := resolver.ResolvePythonVersion()
	toolVersions := resolver.ResolveToolVersions()

	// Validate lock file
	return ValidateLockFile(lockFile, collections, roles, toolVersions, pythonVersion)
}
