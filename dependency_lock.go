package main

import (
	"fmt"
	"os"
	"strings"
	"time"

	"gopkg.in/yaml.v3"
)

// LockFileEntry represents a single dependency entry in the lock file
type LockFileEntry struct {
	Name            string            `yaml:"name"`
	Version         string            `yaml:"version"`
	ResolvedVersion string            `yaml:"resolved_version,omitempty"` // Actual version (e.g., "7.5.0" for ">=7.4.0")
	Type            string            `yaml:"type"`                       // "collection", "role", "tool"
	Hash            string            `yaml:"hash,omitempty"`
	PythonDeps      map[string]string `yaml:"python_deps,omitempty"` // Python dependencies with versions
	Source          string            `yaml:"source,omitempty"`      // "galaxy", "pypi", "git"
}

// LockFile represents the diffusion.lock file structure
type LockFile struct {
	Version     string          `yaml:"version"`     // Lock file format version
	Generated   string          `yaml:"generated"`   // Timestamp
	Hash        string          `yaml:"hash"`        // Overall dependency hash
	Python      *PythonVersion  `yaml:"python"`      // Python version info
	Collections []LockFileEntry `yaml:"collections"` // Locked collections
	Roles       []LockFileEntry `yaml:"roles"`       // Locked roles
	Tools       []LockFileEntry `yaml:"tools"`       // Locked tools (ansible, molecule, etc.)
}

const (
	LockFileVersion = "1.0"
)

// LoadLockFile loads the diffusion.lock file
func LoadLockFile() (*LockFile, error) {
	data, err := os.ReadFile(LockFileName)
	if err != nil {
		if os.IsNotExist(err) {
			return nil, nil // Lock file doesn't exist yet
		}
		return nil, fmt.Errorf("failed to read lock file: %w", err)
	}

	var lockFile LockFile
	if err := yaml.Unmarshal(data, &lockFile); err != nil {
		return nil, fmt.Errorf("failed to parse lock file: %w", err)
	}

	return &lockFile, nil
}

// SaveLockFile saves the lock file
func SaveLockFile(lockFile *LockFile) error {
	lockFile.Version = LockFileVersion
	lockFile.Generated = time.Now().UTC().Format(time.RFC3339)

	data, err := yaml.Marshal(lockFile)
	if err != nil {
		return fmt.Errorf("failed to marshal lock file: %w", err)
	}

	// Add header comment
	header := fmt.Sprintf("# This file is automatically generated by diffusion.\n# Do not edit this file manually.\n# Generated: %s\n\n", lockFile.Generated)
	data = append([]byte(header), data...)

	if err := os.WriteFile(LockFileName, data, 0644); err != nil {
		return fmt.Errorf("failed to write lock file: %w", err)
	}

	return nil
}

// GenerateLockFile generates a new lock file from current dependencies with resolved versions
func GenerateLockFile(collections []CollectionRequirement, roles []RequirementRole, toolVersions map[string]string, pythonVersion *PythonVersion) (*LockFile, error) {
	lockFile := &LockFile{
		Version:     LockFileVersion,
		Python:      pythonVersion,
		Collections: make([]LockFileEntry, 0),
		Roles:       make([]LockFileEntry, 0),
		Tools:       make([]LockFileEntry, 0),
	}

	galaxyAPI := NewGalaxyAPI()

	// Add collections with resolved versions
	for _, col := range collections {
		entry := LockFileEntry{
			Name:    col.Name,
			Version: col.Version,
			Type:    "collection",
			Source:  "galaxy",
		}

		// Resolve version from Galaxy
		resolvedVersion, err := galaxyAPI.ResolveCollectionVersion(col.Name, col.Version)
		if err != nil {
			fmt.Printf("Warning: Failed to resolve version for %s: %v\n", col.Name, err)
			entry.ResolvedVersion = col.Version
		} else {
			entry.ResolvedVersion = resolvedVersion
		}

		// Get Python dependencies for this collection
		pythonDeps := getCollectionPythonDependencies(col.Name)
		if len(pythonDeps) > 0 {
			// Resolve Python package versions
			resolved, err := ResolvePythonDependencies(pythonDeps)
			if err != nil {
				fmt.Printf("Warning: Failed to resolve Python deps for %s: %v\n", col.Name, err)
			} else {
				entry.PythonDeps = resolved
			}
		}

		lockFile.Collections = append(lockFile.Collections, entry)
	}

	// Add roles with resolved versions
	for _, role := range roles {
		entry := LockFileEntry{
			Name:    role.Name,
			Version: role.Version,
			Type:    "role",
			Source:  "galaxy",
		}

		// Parse role name (namespace.name or just name)
		parts := strings.Split(role.Name, ".")
		if len(parts) == 2 {
			resolvedVersion, err := galaxyAPI.ResolveRoleVersion(parts[0], parts[1], role.Version)
			if err != nil {
				fmt.Printf("Warning: Failed to resolve version for role %s: %v\n", role.Name, err)
				entry.ResolvedVersion = role.Version
			} else {
				entry.ResolvedVersion = resolvedVersion
			}
		} else {
			entry.ResolvedVersion = role.Version
		}

		lockFile.Roles = append(lockFile.Roles, entry)
	}

	// Add tools with resolved Python package versions
	toolPackages := []string{}
	for tool, version := range toolVersions {
		entry := LockFileEntry{
			Name:    tool,
			Version: version,
			Type:    "tool",
			Source:  "pypi",
		}

		// Format as Python package
		pkgName := formatDependency(tool, version)
		toolPackages = append(toolPackages, pkgName)

		lockFile.Tools = append(lockFile.Tools, entry)
	}

	// Resolve all tool versions from PyPI
	if len(toolPackages) > 0 {
		resolved, err := ResolvePythonDependencies(toolPackages)
		if err != nil {
			fmt.Printf("Warning: Failed to resolve tool versions: %v\n", err)
		} else {
			// Update tool entries with resolved versions
			for i := range lockFile.Tools {
				if resolvedVer, ok := resolved[lockFile.Tools[i].Name]; ok {
					lockFile.Tools[i].ResolvedVersion = resolvedVer
				}
			}
		}
	}

	// Compute overall hash
	lockFile.Hash = ComputeDependencyHash(collections, roles, toolVersions, pythonVersion)

	return lockFile, nil
}

// ValidateLockFile validates if the lock file is up-to-date
func ValidateLockFile(lockFile *LockFile, collections []CollectionRequirement, roles []RequirementRole, toolVersions map[string]string, pythonVersion *PythonVersion) (bool, error) {
	if lockFile == nil {
		return false, nil
	}

	currentHash := ComputeDependencyHash(collections, roles, toolVersions, pythonVersion)
	return lockFile.Hash == currentHash, nil
}

// UpdateLockFile updates the lock file with current dependencies
func UpdateLockFile() error {
	// Load current configuration
	depConfig, err := LoadDependencyConfig()
	if err != nil {
		return fmt.Errorf("failed to load dependency config: %w", err)
	}

	// Load meta and requirements
	meta, req, err := LoadRoleConfig("")
	if err != nil {
		return fmt.Errorf("failed to load role config: %w", err)
	}

	// Resolve dependencies
	resolver := NewDependencyResolver(meta, req, depConfig)
	collections, err := resolver.ResolveCollectionDependencies()
	if err != nil {
		return fmt.Errorf("failed to resolve collections: %w", err)
	}

	pythonVersion := resolver.ResolvePythonVersion()
	toolVersions := resolver.ResolveToolVersions()

	// Generate and save lock file
	lockFile, err := GenerateLockFile(collections, req.Roles, toolVersions, pythonVersion)
	if err != nil {
		return fmt.Errorf("failed to generate lock file: %w", err)
	}

	if err := SaveLockFile(lockFile); err != nil {
		return fmt.Errorf("failed to save lock file: %w", err)
	}

	return nil
}

// CheckLockFileStatus checks if lock file is up-to-date
func CheckLockFileStatus() (bool, error) {
	lockFile, err := LoadLockFile()
	if err != nil {
		return false, err
	}

	if lockFile == nil {
		return false, nil // No lock file exists
	}

	// Load current configuration
	depConfig, err := LoadDependencyConfig()
	if err != nil {
		return false, fmt.Errorf("failed to load dependency config: %w", err)
	}

	// Load meta and requirements
	meta, req, err := LoadRoleConfig("")
	if err != nil {
		return false, fmt.Errorf("failed to load role config: %w", err)
	}

	// Resolve dependencies
	resolver := NewDependencyResolver(meta, req, depConfig)
	collections, err := resolver.ResolveCollectionDependencies()
	if err != nil {
		return false, fmt.Errorf("failed to resolve collections: %w", err)
	}

	pythonVersion := resolver.ResolvePythonVersion()
	toolVersions := resolver.ResolveToolVersions()

	// Validate lock file
	return ValidateLockFile(lockFile, collections, req.Roles, toolVersions, pythonVersion)
}
